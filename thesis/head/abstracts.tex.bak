%\begingroup
%\let\cleardoublepage\clearpage


% English abstract
\cleardoublepage
\chapter*{Abstract}
%\markboth{Abstract}{Abstract}
\addcontentsline{toc}{chapter}{Abstract} % adds an entry to the table of contents

\vspace{0.7em}

High-level languages allow programmers to express data structures and algorithms that operate on any type of data, regardless of size and semantics: while this is the norm for dynamic languages, statically typed languages also allow this behavior through generics. However, executing such code requires many low-level indirections, which slow down execution. This leads to a pessimistic scenario: even code that does not use the full power of abstraction still pays the full price of indirection. Furthermore, despite the fact that statically typed programming languages limit some of the run-time behaviors of a program, object-oriented language compilers shy away from many optimizations due to their complexity.

\vspace{0.7em}

In the first part of the thesis we present miniboxing, a compile-time transformation that uses the type information available in Scala programs to replace generic classes by more efficient versions, optimized to handle primitive types. These classes, known as variants are fully compatible drop-in replacements for the original class, with the single difference that they use the miniboxed encoding to store data. Thanks to this data representation, storage and operations in variant classes are more efficient, making miniboxed code by up to 20$\times$ faster compared to the original class.

\vspace{0.7em}

Further generalizing the miniboxing transformation, we show the Late Data Layout mechanism, a type-driven transformation framework that can be instantiated to perform the miniboxing code transformations, inlining value classes and unboxing primitive types in high-level languages. The Late Data Layout mechanism has many desirable properties, such as provable correctness in handling different data representations, optimality in terms of conversions introduced and built-in support for the object-oriented paradigm. The current version of the miniboxing transformation uses Late Data Layout under the hood.

\vspace{0.7em}

Finally, we show Data-Centric Metaprogramming, a technique that allows programmers to go beyond the general optimizations already shown by defining custom, improved data representations that the compiler can automatically use when translating a program. This technique, similar in spirit to metaprogramming, is actually more restrictive and well-behaved, opening new opportunities for programmer-driven optimizations and showing encouraging results, with speedups of up to 25$\times$. Under the hood, Data-Centric Metaprogramming uses the Late Data Layout mechanism.

% \vspace{1em}
%
% Finally, we show how the miniboxing transformation ties uses all the research artifacts presented in the thesis to deliver reliable speedups for generic programs.

\vspace{1.2em}
Key words:
Data Representation; Transformation; Object-Oriented; Static Type System; Performance; Generics; Specialization; Java; Java Virtual Machine; Bytecode; Safety; Semantics.




% % German abstract
% \begin{otherlanguage}{german}
% \cleardoublepage
% \chapter*{Zusammenfassung}
% %\markboth{Zusammenfassung}{Zusammenfassung}
% % put your text here
% \lipsum[1-2]
% \vskip0.5cm
% Stichwörter:
% %put your text here
% \end{otherlanguage}




% % French abstract
% \begin{otherlanguage}{french}
% \cleardoublepage
% \chapter*{Résumé}
% %\markboth{Résumé}{Résumé}
% % put your text here
% \lipsum[1-2]
% \vskip0.5cm
% Mots clefs:
% %put your text here
% \end{otherlanguage}


%\endgroup
%\vfill
