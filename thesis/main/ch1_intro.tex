\chapter{Introduction}
% \addcontentsline{toc}{chapter}{Introduction}

A computer's processor is an amazing device: it executes millions of operations each second, at a speed difficult to grasp for any human. Still, these operations are simple, precise instructions: read 32 bits from memory address X into register R1, extend the number in R1 to a 64 bit unsigned integer in register R2 and so on. For the processor, data is made up of bits and each operation needs to know the exact size and semantics of the data, since this selects which set of bitwise operations will be executed.

On the completely opposite side of the spectrum, people think in terms of very high-level goals, such as the desire to find the average temperature over a day or a week. Programming languages and compilers bridge the gap between the complex and abstract high-level goals and the precise low-level machine code necessary to fulfill them: Programming languages allow people to express their intent while compilers translate this intent, written in the source code, to low-level machine code.

Programming lanugages have long struggled with a dilemma: exposing low-level data types and low level operations allows very good control and easy translation, but reduces the programmer productivity. Indeed, programming languages such as Assmbly and C allow very precise control over all aspects of the computation and the interaction between the processor and the other devices in the computer, such as the network interface card. Yet this forces the programmer to make many decisions that are not directly related to the problem: how to store data, how each operation will manipulate it and what needs to be done at each step. As customizable as this makes the program, exposing so many extaneous decisions makes development tedious and error-prone.

The other alternative is exposing very high-level data structures and operations in the programming language. Indeed, languages such as Scala, Python, Ruby, JavaScript gloss over many implementation details to offer the programmers a high-level environment that boosts productivity. For example, Python automatically takes care of extending the bit count when a number overflows. The Scala standard library offers data structures such as arrays, vectors, lists that are parametric in the type of their element: they can be statically guaranteed to only store a single type of values, be that integers, floating-point numbers, database records or objects representing other nested data structures. But this flexibility comes at the price of efficiency: the high-level code is compiled to long sequences of machine instructions, where most of the data is passed as pointers to memory-allocated objects and where operations are executed through indirect calls. Despite the processor execution speed, these operations can incur orders of magnitude of slowdowns.

Instead of compiling the high-level constructs into long and indirect low-level code and using that, a solution that can be employed is to replace them by more efficient ones, that contain more efficient low-level code. In this context, constructs can mean primitive data types, data structures and entire object hierachies, all of which can be replaced by specialized versions, semantically equivalents that are more efficiently implemented.

This is where this thesis makes its contribution: it proposes a general mechanism that allows compilers for object-oriented languages to optimally and safely replace the high-level constructs in their compliled programs. The key feature of this mechanism is its predictable nature, compared to the common compiler optimizations that are usually opportunistic and may or may not kick in based on their heuristics. Furthermore, we have shown that the mechanism is general enough to accommodate a wide range of transformations: from improving generics, avoiding heap allocation and all the way to allowing programmers to fine-tune their data structures after the fact.



%% Story of development:
%  1. miniboxing
%  2. LDL
%  3. iLDL
\paragraph*{Generics Specialization.} The first chapter ...


\cite{st-amour-opt-coaching}

\section{Context and Goals}

This section describes the context of the work, motivating decisions with examples and will show the contributions at a glance.

\subsection{Implicit Representation Choice}


\subsection{Object Oriented Model}

% Natural paradigm.
% Object-oriented paradigm -- very natural as it follows intensional definitions: genus/differentia deffinition
%   Example Automobile -- Car, Motorcycle, ..., Tesla (Car with Electric)

% Reuse -
%  -- implementation reuse (List, Vector, Map)
%  -- conceptual reuse (according to Einstein, we know the speed is less than c, which is approximately 1.1*10^9 km/h and above 0), we we use 32-bit integers

% Implicit memory management

% reflection

\subsection{Compile-Time Transformation}

\subsection{Configurability and Optimality}

\subsection{Open World Assumption}


\section{Contributions}
